#!/usr/bin/lua

-- FWWRT authentication portal helper methods
--
-- Daniel Podolsky, tpaba@cpan.org, 2009-08-04
-- Roman Belyakovsky, roman.belyakovsky@gmail.com
-- Licence is the same as OpenWRT


module("fwwrt.authportal", package.seeall)

require "wsapi.util"
require "wsapi.request"
require "cosmo"
require "luasql.sqlite"

require "fwwrt.util"
require "fwwrt.iptkeeper"
require "fwwrt.dbBackend"

local webDir     = fwwrt.util.uciGet('httpd.httpd.home',            'string')
local hostname   = fwwrt.util.uciGet('fwwrt.authportal.httpsName',  'string')
local loginDelay = fwwrt.util.uciGet('fwwrt.authportal.logindelay', 'number')
local dbFile     = fwwrt.util.uciGet('fwwrt.authportal.dbFile',     'string')
--local ssid       = fwwrt.util.uciGet('wireless.wifi-iface.ssid',  'string')

local statement = {allActive  = [[SELECT DISTINCT
                                   u.userid          AS userid
                                  ,a.logintime       AS logintime
                                  ,u.totalTimeUsed   AS totalTimeUsed
                                  FROM       activeusers AS a
                                  INNER JOIN users       AS u ON (u.userid = a.userid)
                                ]]
                  ,oneActive  = [[SELECT DISTINCT
                                   u.userid          AS userid
                                  ,a.logintime       AS logintime
                                  ,u.totalTimeUsed   AS totalTimeUsed
                                  FROM       activeusers AS a
                                  INNER JOIN users       AS u ON (u.userid = a.userid)
                                  WHERE a.ipaddr = ?
                                ]]
                  ,userById   = [[SELECT DISTINCT
                                   u.userid          AS userid
                                  ,t.totalTimeLim    AS totalTimeLim
                                  ,u.autogenerated   AS autogenerated
                                  ,u.username        AS username
                                  ,t.multisession    AS multisession
                                  ,u.sessionsUsed    AS sessionsUsed
                                  ,u.sessionTrafUsed AS sessionTrafUsed
                                  ,u.totalTimeUsed   AS totalTimeUsed
                                  ,u.password        AS password
                                  ,t.tarifid         AS tarifid
                                  ,u.totalTrafUsed   AS totalTrafUsed
                                  ,u.sessionTimeUsed AS sessionTimeUsed
                                  FROM       users  AS u
                                  INNER JOIN tarifs AS t ON (t.tarifid = u.tarifid)
                                  WHERE u.userid = ?
                                ]]
                  ,updateUser = "UPDATE users set totalTimeUsed = ? where userid = ?"
                  ,addActive  = "INSERT INTO activeusers (ipaddr, userid, logintime) VALUES (?,?,?)"
				  ,delActive  = "DELETE FROM activeusers WHERE userid = ?"
                  ,userByName = [[SELECT DISTINCT
                                   u.userid          AS userid
                                  ,t.totalTimeLim    AS totalTimeLim
                                  ,u.autogenerated   AS autogenerated
                                  ,u.username        AS username
                                  ,t.multisession    AS multisession
                                  ,u.sessionsUsed    AS sessionsUsed
                                  ,u.sessionTrafUsed AS sessionTrafUsed
                                  ,u.totalTimeUsed   AS totalTimeUsed
                                  ,u.password        AS password
                                  ,t.tarifid         AS tarifid
                                  ,u.totalTrafUsed   AS totalTrafUsed
                                  ,u.sessionTimeUsed AS sessionTimeUsed
                                  FROM       users  AS u
                                  INNER JOIN tarifs AS t ON (t.tarifid = u.tarifid)
                                  WHERE u.username = ?
                                ]]
                  ,tarifById  = "SELECT * FROM tarifs WHERE tarifid = ?"
                  }

dbCon = fwwrt.dbBackend.connect()

local key, val
for key, val in pairs(statement)
	do
	if (type(val) == 'string')
		then
		statement[key] = dbCon:prepare(val)
	end
end

commonHeaders   = {["Content-type"] = "text/html; charset=utf-8"
                        }
function redirectHeaders(path)
	return {["Content-type"] = "text/html; charset=utf-8"
	       ,["Location"]     = path
	       }
end

function yieldSleep()
	fwwrt.util.yieldSleep(loginDelay, "")
end

function showLogoutForm(wsapi_env) --showlogin
	local template  = fwwrt.util.fileToVariable(webDir.."/showLogout.template")
	local values = {actionUrl = "http://"..hostname.."/logout"
	               ,origUrl   = "http://"..hostname.."/"
	               }

	local process = function () coroutine.yield(cosmo.fill(template, values)) end
	return 200, commonHeaders, coroutine.wrap(process)
end

function processLogoutForm(wsapi_env) --showlogin
	local request  = wsapi.request.new(wsapi_env)

    if (not (request.POST and request.POST.logout))
    	then return showLogoutForm(wsapi_env) end

    fwwrt.iptkeeper.logIpOut(wsapi_env.REMOTE_ADDR)
	return 302, redirectHeaders("http://"..hostname.."/"), coroutine.wrap(yieldSleep)
end

function doLogout(ip)
	local userCur
	local userRow
	local cur = fwwrt.dbBackend.bindAndExecute(statement.oneActive, {'TEXT', ip})
	local row = cur:fetch ({}, "a")	-- the rows will be indexed by field names
	cur:close()
	doLogoutId(row)
end

function doLogoutId(row)
	local reset    = fwwrt.dbBackend.bindAndExecute(statement.updateUser 
		--,updateUser = "UPDATE users totalTimeUsed = ? where userid = ?"
		                                  ,{'INTEGER' ,os.time() - row.logintime + row.totalTimeUsed}
		                                  ,{'INTEGER' ,row.userid}
		                                   )
	local activesCur = fwwrt.dbBackend.bindAndExecute(statement.delActive
	--	  ,delActive  = "DELETE FROM activeusers WHERE userid = ?"	
	                                          ,{'INTEGER'    ,row.userid}
	                                          )
end

function doLogoutAll()
	local cur = fwwrt.dbBackend.bindAndExecute(statement.allActive)
	local row = cur:fetch ({}, "a")	-- the rows will be indexed by field names
	cur:close()
	while row do
		doLogoutId(row)
		cur = fwwrt.dbBackend.bindAndExecute(statement.allActive)
		row = cur:fetch (row, "a")	-- reusing the table of results
		cur:close()
	end
end

function doLogin(ip, userid)
	local cur = fwwrt.dbBackend.bindAndExecute(statement.addActive -- and no assert here!
	                                          ,{'TEXT'    ,ip}
	                                          ,{'INTEGER' ,userid}
	                                          ,{'INTEGER' ,os.time()}
	                                          )
	return (cur == 1)
end

function showLoginForm(wsapi_env, reason, message) --showlogin
    reason = reason or ""
	local loginText = ""
	local wrong     = ""
	local pass      = fwwrt.util.fileToVariable(webDir.."/loginNoPass.template")
	local template  = fwwrt.util.fileToVariable(webDir.."/showLogin.template")
	local values    = {actionUrl = "https://"..hostname.."/"
	                  ,origUrl   = "http://"..wsapi_env.SERVER_NAME..wsapi_env.PATH_INFO
	                  ,loginText = loginText
	                  ,pass      = pass
	                  ,wrong     = wrong
	                  ,reason    = reason
	                  }

	local process = function () coroutine.yield(cosmo.fill(template, values)) end
	return 200, commonHeaders, coroutine.wrap(process)
end

function checkLogin(user)
	local cur = fwwrt.dbBackend.bindAndExecute(statement.userByName
	                                          ,{'TEXT', user}
	                                          )
	-- row = cur:fetch ({}, "a")	-- the rows will be indexed by field names
	
	local info = assert(cur:fetch({}, "a"), "user doesn't exist") --change userid to expire or hwatever

	cur:close()
	return info.userid, info.totalTimeUsed, info.totalTimeLim
end

function processLoginForm(wsapi_env) --doLogin, show logout
	local request  = wsapi.request.new(wsapi_env)

    if (not (request.POST and request.POST.username and request.POST.password and request.POST.origUrl))
    	then
		fwwrt.util.logger("LOG_ERR", "Bad request from '"..wsapi_env.REMOTE_ADDR.."'")
		return showLoginForm(wsapi_env, "badRequest", "")
    end

    local authorized, userid, totalTimeUsed, totalTimeLim = pcall(checkLogin, request.POST.username)

    if (not authorized) then
		fwwrt.util.logger("LOG_ERR", "Bad login for '"..request.POST.username.."' from '"..wsapi_env.REMOTE_ADDR.."': "..userid)
		return showLoginForm(wsapi_env, "badLogin", userid)
	end
	

	local expire = os.time() + totalTimeLim - totalTimeUsed
	print("limit = '"..totalTimeLim.."' used = '"..totalTimeUsed..
	"' lim - used = '"..totalTimeLim-totalTimeUsed.."'")
	print(request.POST.username .." expires on "..os.date(t, expire).."\n logged in on "..os.date())
	
    if (not fwwrt.iptkeeper.logIpIn(wsapi_env.REMOTE_ADDR, expire))
    	then
		fwwrt.util.logger("LOG_ERR", "Bad login for '"..request.POST.username.."' from '"..wsapi_env.REMOTE_ADDR.."': address unknown")
		return showLoginForm(wsapi_env, "unknownIP")
	end
	
	doLogin(wsapi_env.REMOTE_ADDR, userid) -- no pcall here!
	
	local template = fwwrt.util.fileToVariable(webDir.."/showLogout.template")
	
	-- fwwrt.util.logger("LOG_INFO", "User '"..request.POST.username.."' logged in on '"..wsapi_env.REMOTE_ADDR.."'")

	local values = {actionUrl = "https://"..hostname.."/"
	               ,origUrl   = request.POST.origUrl
	               }
	
	local process = function ()
	    yieldSleep()
		coroutine.yield(cosmo.fill(template, values))
		coroutine.yield("<pre>"..fwwrt.util.printTable(wsapi_env, "rwsapi_env", ".", 10).."</pre>")
		coroutine.yield("<pre>"..fwwrt.util.printTable(request,   "request",    ".", 10).."</pre>")
		end
	
	return 200, commonHeaders, coroutine.wrap(process)
end

doLogoutAll()
