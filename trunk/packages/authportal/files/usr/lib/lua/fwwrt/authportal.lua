#!/usr/bin/lua

-- FWWRT authentication portal helper methods
--
-- Daniel Podolsky, tpaba@cpan.org, 2009-08-04
-- Roman Belyakovsky, roman.belyakovsky@gmail.com
-- Licence is the same as OpenWRT


module("fwwrt.authportal", package.seeall)

require "wsapi.request"
require "cosmo"
require "luasql.sqlite"

require "fwwrt.util"
require "fwwrt.iptkeeper"
require "fwwrt.dbBackend"
require "fwwrt.simplelp"

local webDir        = fwwrt.util.uciGet('httpd.httpd.home',            'string')
local hostname      = fwwrt.util.uciGet('fwwrt.authportal.httpsName',  'string')
local loginDelay    = fwwrt.util.uciGet('fwwrt.authportal.logindelay', 'number')
local dbFile        = fwwrt.util.uciGet('fwwrt.authportal.dbFile',     'string')
local showLogout    = fwwrt.util.uciGet('fwwrt.show.logout',           'boolean')
local showDetails   = fwwrt.util.uciGet('fwwrt.show.details',          'boolean')
local showAdminLink = fwwrt.util.uciGet('fwwrt.show.adminlink',        'boolean')

--local ssid       = fwwrt.util.uciGet('wireless.wifi-iface.ssid',  'string')

local statement = {allActive  = [[SELECT DISTINCT
                                   u.userid          AS userid
                                  ,a.logintime       AS logintime
                                  ,u.totalTimeUsed   AS totalTimeUsed
                                  FROM       activeusers AS a
                                  INNER JOIN users       AS u ON (u.userid = a.userid)
                                ]]
                  ,oneActive  = [[SELECT DISTINCT
                                   u.userid          AS userid
                                  ,a.logintime       AS logintime
                                  ,u.totalTimeUsed   AS totalTimeUsed
                                  FROM       activeusers AS a
                                  INNER JOIN users       AS u ON (u.userid = a.userid)
                                  WHERE a.ipaddr = ?
                                ]]
                  ,userById   = [[SELECT DISTINCT
                                   u.userid          AS userid
                                  ,t.totalTimeLim    AS totalTimeLim
                                  ,u.autogenerated   AS autogenerated
                                  ,u.username        AS username
                                  ,t.multisession    AS multisession
                                  ,u.sessionsUsed    AS sessionsUsed
                                  ,u.sessionTrafUsed AS sessionTrafUsed
                                  ,u.totalTimeUsed   AS totalTimeUsed
                                  ,u.password        AS password
                                  ,t.tarifid         AS tarifid
                                  ,u.totalTrafUsed   AS totalTrafUsed
                                  ,u.sessionTimeUsed AS sessionTimeUsed
                                  FROM       users  AS u
                                  INNER JOIN tarifs AS t ON (t.tarifid = u.tarifid)
                                  WHERE u.userid = ?
                                ]]
                  ,updateUser = "UPDATE users set totalTimeUsed = ? where userid = ?"
                  ,addActive  = "INSERT INTO activeusers (ipaddr, userid, logintime) VALUES (?,?,?)"
                  ,delActive  = "DELETE FROM activeusers WHERE userid = ?"
                  ,userByName = [[SELECT DISTINCT
                                   u.userid          AS userid
                                  ,t.totalTimeLim    AS totalTimeLim
                                  ,u.autogenerated   AS autogenerated
                                  ,u.username        AS username
                                  ,t.multisession    AS multisession
                                  ,u.sessionsUsed    AS sessionsUsed
                                  ,u.sessionTrafUsed AS sessionTrafUsed
                                  ,u.totalTimeUsed   AS totalTimeUsed
                                  ,u.password        AS password
                                  ,t.tarifid         AS tarifid
                                  ,u.totalTrafUsed   AS totalTrafUsed
                                  ,u.sessionTimeUsed AS sessionTimeUsed
                                  FROM       users  AS u
                                  INNER JOIN tarifs AS t ON (t.tarifid = u.tarifid)
                                  WHERE u.username = ?
                                ]]
                  ,tarifById  = "SELECT * FROM tarifs WHERE tarifid = ?"
}

dbCon = fwwrt.dbBackend.connect()

local key, val
for key, val in pairs(statement)
	do
	if (type(val) == 'string')
		then
		statement[key] = dbCon:prepare(val)
	end
end

commonHeaders   = {["Content-type"] = "text/html; charset=utf-8"
                        }
function redirectHeaders(path)
	return {["Content-type"] = "text/html; charset=utf-8"
	       ,["Location"]     = path
	       }
end

function yieldSleep()
	fwwrt.util.yieldSleep(loginDelay, "")
end

function showLogoutForm(wsapi_env) --showlogin
	local values = {actionUrl = "http://"..hostname.."/logout"
	               ,origUrl   = "http://"..hostname.."/"
	               }
	local template  = fwwrt.simplelp.loadFile(webDir.."/showLogout.template", values)
	local process = function () coroutine.yield(template:run(values)) end
	return 200, commonHeaders, coroutine.wrap(process)
end

function processLogoutForm(wsapi_env) --showlogin
	local request  = wsapi.request.new(wsapi_env)
	fwwrt.iptkeeper.logIpOut(wsapi_env.REMOTE_ADDR)
	return showLoginForm(wsapi_env, "http://"..hostname.."/", "logged out successfully")
end

function doLogout(ip)
	local userCur
	local userRow
	local cur = fwwrt.dbBackend.bindAndExecute(statement.oneActive, {'TEXT', ip})
	local row = cur:fetch ({}, "a")	-- the rows will be indexed by field names
	cur:close()
	doLogoutId(row)
end

function doLogoutId(row)
	local reset    = fwwrt.dbBackend.bindAndExecute(statement.updateUser 
		--,updateUser = "UPDATE users totalTimeUsed = ? where userid = ?"
		                                  ,{'INTEGER' ,os.time() - row.logintime + row.totalTimeUsed}
		                                  ,{'INTEGER' ,row.userid}
		                                   )
	local activesCur = fwwrt.dbBackend.bindAndExecute(statement.delActive
	--	  ,delActive  = "DELETE FROM activeusers WHERE userid = ?"	
	                                          ,{'INTEGER'    ,row.userid}
	                                          )
end

function doLogoutAll()
	local cur = fwwrt.dbBackend.bindAndExecute(statement.allActive)
	local row = cur:fetch ({}, "a")	-- the rows will be indexed by field names
	cur:close()
	while row do
		doLogoutId(row)
		cur = fwwrt.dbBackend.bindAndExecute(statement.allActive)
		row = cur:fetch (row, "a")	-- reusing the table of results
		cur:close()
	end
end

function doLogin(ip, userid)
	local cur = fwwrt.dbBackend.bindAndExecute(statement.addActive -- and no assert here!
	                                          ,{'TEXT'    ,ip}
	                                          ,{'INTEGER' ,userid}
	                                          ,{'INTEGER' ,os.time()}
	                                          )
	return (cur == 1)
end

function showLoginForm(wsapi_env, oriurl, reason, message) --showlogin
	local reason = reason or ""
	local loginText = ""
	local wrong     = ""
	local pass      = fwwrt.util.fileToVariable(webDir.."/loginNoPass.template")
	local template  = fwwrt.util.fileToVariable(webDir.."/showLogin.template")
	local values    = {actionUrl = "https://"..hostname.."/",
						dir = webDir,
	                  loginText = loginText
	                  ,pass      = pass
	                  ,wrong     = wrong
	                  }
	local env = {
		origUrl   = oriurl or "http://"..wsapi_env.SERVER_NAME..wsapi_env.PATH_INFO,
		reason    = reason
	}
	local template = fwwrt.simplelp.loadFile(webDir.."/showLogin.template", values)

	local process = function () coroutine.yield(template:run(env)) end
	return 200, commonHeaders, coroutine.wrap(process)
end

function checkLogin(user)
	local cur = fwwrt.dbBackend.bindAndExecute(statement.userByName
	                                          ,{'TEXT', user}
	                                          )
--	local info = assert(cur:fetch({}, "a"), "user doesn't exist") --change userid to expire or hwatever
	local info = cur:fetch({}, "a")
	cur:close()
--	print("db, userid = "..tostring(info.userid))
	if info then return true, info.userid, info.totalTimeUsed, info.totalTimeLim end
	return nil
end

function processLoginForm(wsapi_env) --doLogin, show logout
	local request  = wsapi.request.new(wsapi_env)

    if (not (request.POST and ((request.POST.username and request.POST.password and request.POST.origUrl) or request.POST.logout))) -- oh my...
		then --hacking?
		fwwrt.util.logger("LOG_ERR", "Bad request from '"..wsapi_env.REMOTE_ADDR.."': not a proper POST")
		coroutine.wrap(yieldSleep)
		return showLoginForm(wsapi_env, hostname, "bad request", "not a proper post request")
    end

	if request.POST.logout then return processLogoutForm(wsapi_env) end

--    local authorized, userid, totalTimeUsed, totalTimeLim = pcall(checkLogin, request.POST.username)
    local authorized, userid, totalTimeUsed, totalTimeLim = checkLogin(request.POST.username)
	print("userid = "..tostring(userid) )

    if (not authorized) then
		fwwrt.util.logger("LOG_ERR", "Bad login for '"..request.POST.username.."' from '"..wsapi_env.REMOTE_ADDR.."': "..tostring(userid))
		return showLoginForm(wsapi_env, request.POST.origUrl, "code incorrect: '"..request.POST.username.."'")
	end --                  (wsapi_env, oriurl, reason, message)
	
	local expire = os.time() + totalTimeLim - totalTimeUsed
	
	if expire <= 0 then
		fwwrt.util.logger("LOG_ERR", "Bad login for '"..request.POST.username.."' from '"..wsapi_env.REMOTE_ADDR.."': "..userid.." â€“ expired")
		return showLoginForm(wsapi_env, request.POST.origUrl, "expired", userid)
	end
	
	fwwrt.util.logger("LOG_DEBUG","limit = '"..totalTimeLim.."' used = '"..totalTimeUsed..
		"' lim - used = '"..totalTimeLim-totalTimeUsed.."'")
	fwwrt.util.logger("LOG_DEBUG",request.POST.username .." expires on "..os.date(t, expire)..
		" logged in on "..os.date())
	
    if (not fwwrt.iptkeeper.logIpIn(wsapi_env.REMOTE_ADDR, expire))
    	then
		fwwrt.util.logger("LOG_ERR", "Bad login for '"..request.POST.username.."' from '"..wsapi_env.REMOTE_ADDR.."': address unknown")
		return showLoginForm(wsapi_env, request.POST.origUrl, "unknownIP")
	end
	
	if not pcall(doLogin, wsapi_env.REMOTE_ADDR, userid) then -- if we already have 
		doLogout(wsapi_env.REMOTE_ADDR)                       -- this ip in activeDB
		doLogin (wsapi_env.REMOTE_ADDR, userid)
	end
	
	fwwrt.util.logger("LOG_INFO", "User '"..request.POST.username.."' logged in on '"..wsapi_env.REMOTE_ADDR.."'")

	local values = {actionUrl = "https://"..hostname.."/", dir = webDir}
	local template = fwwrt.simplelp.loadFile(webDir.."/showLogout.template", values)
	local env = {
		origUrl = request.POST.origUrl
--		ip = wsapi_env.REMOTE_ADDR, user = <%=env.user%> ip = <%=env.ip%> expire = <%=env.expire%> logintime = <%=env.logintime%>
--		user = request.POST.username,
--		expire = expire
		}
	local process = function ()
		yieldSleep()
		coroutine.yield(template:run(env))
--		coroutine.yield("<pre>"..fwwrt.util.printTable(wsapi_env, "rwsapi_env", ".", 10).."</pre>")
--		coroutine.yield("<pre>"..fwwrt.util.printTable(request,   "request",    ".", 10).."</pre>")
		end
		
	return 200, commonHeaders, coroutine.wrap(process)
end

doLogoutAll()
